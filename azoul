// server.mjs
// Express API + HTML UI + SQLite storage for Employee Reports
// Adds: per-row "×" delete button (soft delete by default; Shift+Click for hard delete)
// -----------------------------------------------------------------------------

import express from "express";
import path from "path";
import { fileURLToPath } from "url";
import Database from "better-sqlite3";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const app = express();
app.use(express.json());

// ---------- Database ----------
const db = new Database(path.join(__dirname, "employee_reports.db"));
db.exec(`
CREATE TABLE IF NOT EXISTS reports (
  id TEXT PRIMARY KEY,
  email TEXT,
  issue TEXT,
  tags TEXT,             -- JSON array of strings
  created_at TEXT,       -- ISO timestamp
  deleted_at TEXT        -- ISO timestamp or NULL
);
`);

const count = db.prepare(`SELECT COUNT(*) as c FROM reports`).get().c;
if (count === 0) {
  const seed = db.prepare(`
    INSERT INTO reports (id, email, issue, tags, created_at, deleted_at)
    VALUES (@id, @email, @issue, @tags, @created_at, NULL)
  `);
  const now = new Date();
  const iso = (d) => new Date(d).toISOString();
  const rows = [
    { id: idGen(), email: "javaughnfewe6@gmail.com", issue: "n/a", tags: ["Burnout"], created_at: iso(now) },
    { id: idGen(), email: "javaughnfewe6@gmail.com", issue: "n/a", tags: ["No issue selected"], created_at: iso(now) },
    { id: idGen(), email: "javaughnfewe6@gmail.com", issue: "n/a", tags: ["Burnout"], created_at: iso(now) },
    { id: idGen(), email: "Unknown", issue: "N/A", tags: ["Culture"], created_at: iso(now) },
    { id: idGen(), email: "Unknown", issue: "N/A", tags: ["Safety"], created_at: iso(now) },
    { id: idGen(), email: "Unknown", issue: "N/A", tags: ["Culture"], created_at: iso(now) },
    { id: idGen(), email: "Unknown", issue: "N/A", tags: ["Management"], created_at: iso(now) },
    { id: idGen(), email: "Unknown", issue: "N/A", tags: ["Benefits"], created_at: iso(now) },
    { id: idGen(), email: "Unknown", issue: "N/A", tags: ["Overtime"], created_at: iso(now) },
    { id: idGen(), email: "Unknown", issue: "N/A", tags: ["Low Pay"], created_at: iso(now) },
    { id: idGen(), email: "Unknown", issue: "N/A", tags: ["Career Growth"], created_at: iso(now) },
    { id: idGen(), email: "Unknown", issue: "N/A", tags: ["Other"], created_at: iso(now) },
  ];
  const tx = db.transaction((arr) => arr.forEach((r) => seed.run({ ...r, tags: JSON.stringify(r.tags) })));
  tx(rows);
  console.log(`Seeded ${rows.length} demo reports.`);
}

function idGen() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, c => {
    const r = (Math.random() * 16) | 0;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

// ---------- Helpers ----------
const listStmt = db.prepare(`
  SELECT id, email, issue, tags, created_at, deleted_at
  FROM reports
  WHERE (@includeDeleted = 1 OR deleted_at IS NULL)
  ORDER BY datetime(created_at) DESC
`);

function normalizeFilter(f = {}) {
  return {
    emailIsUnknown: !!f.emailIsUnknown,
    tagIn: Array.isArray(f.tagIn) ? f.tagIn.filter(Boolean) : [],
    createdAfter: f.createdAfter || null,
    createdBefore: f.createdBefore || null,
    includeDeleted: !!f.includeDeleted,
  };
}

function safeParseJson(s, fallback) {
  try { return JSON.parse(s); } catch { return fallback; }
}

let lastSoftDeletedIds = [];

// ---------- API: List ----------
app.get("/api/reports", (req, res) => {
  const includeDeleted = req.query.includeDeleted === "true" ? 1 : 0;
  const rows = listStmt.all({ includeDeleted });
  res.json(rows.map(r => ({ ...r, tags: safeParseJson(r.tags, []) })));
});

// ---------- API: Bulk delete ----------
const deleteByIdsSoft = db.prepare(`
  UPDATE reports SET deleted_at = @now
  WHERE id IN (SELECT value FROM json_each(@idsJson)) AND deleted_at IS NULL
`);
const deleteByIdsHard = db.prepare(`DELETE FROM reports WHERE id IN (SELECT value FROM json_each(@idsJson))`);

app.post("/api/reports/bulk-delete", (req, res) => {
  try {
    const { ids, softDelete = true } = req.body || {};
    if (!Array.isArray(ids) || ids.length === 0) {
      return res.status(400).json({ error: "ids[] required" });
    }
    const idsJson = JSON.stringify(ids);
    let deleted = 0;

    if (softDelete) {
      const now = new Date().toISOString();
      const info = deleteByIdsSoft.run({ now, idsJson });
      deleted = info.changes || 0;
      const updatedRows = db.prepare(`
        SELECT id FROM reports
        WHERE id IN (SELECT value FROM json_each(@idsJson)) AND deleted_at IS NOT NULL
      `).all({ idsJson });
      lastSoftDeletedIds = updatedRows.map(r => r.id);
    } else {
      const info = deleteByIdsHard.run({ idsJson });
      deleted = info.changes || 0;
      lastSoftDeletedIds = [];
    }
    res.json({ deleted });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// ---------- API: Delete by filter ----------
function buildDeleteByFilter(filter, soft) {
  const { emailIsUnknown, tagIn, createdAfter, createdBefore } = normalizeFilter(filter);
  const where = [];
  const params = {};

  if (emailIsUnknown) where.push(`(email IS NULL OR email = '' OR email = 'Unknown')`);
  if (tagIn?.length) {
    where.push(`EXISTS (SELECT 1 FROM json_each(reports.tags) WHERE json_each.value IN (${tagIn.map((_, i) => `@tag_${i}`).join(", ")}))`);
    tagIn.forEach((t, i) => (params[`tag_${i}`] = t));
  }
  if (createdAfter) { where.push(`datetime(created_at) >= datetime(@createdAfter)`); params.createdAfter = createdAfter; }
  if (createdBefore) { where.push(`datetime(created_at) <= datetime(@createdBefore)`); params.createdBefore = createdBefore; }
  if (soft) where.push(`deleted_at IS NULL`);

  const sql = soft
    ? `UPDATE reports SET deleted_at = @now ${where.length ? "WHERE " + where.join(" AND ") : ""}`
    : `DELETE FROM reports ${where.length ? "WHERE " + where.join(" AND ") : ""}`;

  return { sql, params };
}

const selectCountFiltered = (filter) => {
  const { emailIsUnknown, tagIn, createdAfter, createdBefore, includeDeleted } = normalizeFilter(filter);
  const where = [];
  const params = { includeDeleted: includeDeleted ? 1 : 0 };

  if (!includeDeleted) where.push(`deleted_at IS NULL`);
  if (emailIsUnknown) where.push(`(email IS NULL OR email = '' OR email = 'Unknown')`);
  if (tagIn?.length) {
    where.push(`EXISTS (SELECT 1 FROM json_each(reports.tags) WHERE json_each.value IN (${tagIn.map((_, i) => `@tag_${i}`).join(", ")}))`);
    tagIn.forEach((t, i) => (params[`tag_${i}`] = t));
  }
  if (createdAfter) { where.push(`datetime(created_at) >= datetime(@createdAfter)`); params.createdAfter = createdAfter; }
  if (createdBefore) { where.push(`datetime(created_at) <= datetime(@createdBefore)`); params.createdBefore = createdBefore; }

  const sql = `SELECT COUNT(*) as c FROM reports ${where.length ? "WHERE " + where.join(" AND ") : ""}`;
  return { sql, params };
};

app.post("/api/reports/delete-by-filter", (req, res) => {
  try {
    const { softDelete = true, ...filter } = req.body || {};
    const { sql: countSql, params: countParams } = selectCountFiltered({ ...filter, includeDeleted: softDelete ? false : true });
    const { c: wouldAffect } = db.prepare(countSql).get(countParams);

    const { sql, params } = buildDeleteByFilter(filter, !!softDelete);
    let changed = 0;

    if (softDelete) {
      const now = new Date().toISOString();
      const info = db.prepare(sql).run({ ...params, now });
      changed = info.changes || 0;

      // capture IDs affected for undo
      const wherePreview = sql.replace(/^UPDATE reports SET deleted_at = @now\s+WHERE\s+/i, "WHERE ");
      const selectSql = wherePreview.startsWith("WHERE ")
        ? `SELECT id FROM reports ${wherePreview}`
        : `SELECT id FROM reports`;
      const updated = db.prepare(selectSql).all(params);
      lastSoftDeletedIds = updated.map(r => r.id);
    } else {
      const info = db.prepare(sql).run(params);
      changed = info.changes || 0;
      lastSoftDeletedIds = [];
    }
    res.json({ deleted: changed, wouldAffect });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// ---------- API: Single-row delete (used by the "×" button) ----------
app.delete("/api/reports/:id", (req, res) => {
  try {
    const { id } = req.params;
    const soft = req.query.soft !== "false"; // default true
    if (soft) {
      const now = new Date().toISOString();
      const info = db.prepare(`UPDATE reports SET deleted_at = ? WHERE id = ? AND deleted_at IS NULL`).run(now, id);
      lastSoftDeletedIds = info.changes ? [id] : [];
      return res.json({ deleted: info.changes || 0, soft: true });
    } else {
      const info = db.prepare(`DELETE FROM reports WHERE id = ?`).run(id);
      lastSoftDeletedIds = [];
      return res.json({ deleted: info.changes || 0, soft: false });
    }
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// ---------- API: Undo ----------
app.post("/api/reports/undo", (_req, res) => {
  try {
    if (!lastSoftDeletedIds.length) return res.json({ restored: 0 });
    const idsJson = JSON.stringify(lastSoftDeletedIds);
    const info = db.prepare(`UPDATE reports SET deleted_at = NULL WHERE id IN (SELECT value FROM json_each(@idsJson))`).run({ idsJson });
    const restored = info.changes || 0;
    lastSoftDeletedIds = [];
    res.json({ restored });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// ---------- Export ----------
app.get("/api/export", (_req, res) => {
  const rows = db.prepare(`SELECT * FROM reports ORDER BY datetime(created_at) DESC`).all();
  res.type("json").send(JSON.stringify(rows.map(r => ({ ...r, tags: safeParseJson(r.tags, []) })), null, 2));
});

// ---------- UI ----------
app.get("/", (_req, res) => res.type("html").send(renderHtml()));

function renderHtml() {
  return /* html */ `
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Employee Reports – Admin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0b1620;
      --panel: #0f2133;
      --panel2: #0d1b2a;
      --text: #eaf2fb;
      --muted: #93a4b7;
      --warn: #f7b801;
      --danger: #ff6b6b;
      --accent: #4bb6f0;
    }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: var(--bg); color: var(--text); }
    header { display:flex; align-items:center; justify-content:space-between; padding: 16px 20px; background: linear-gradient(180deg, #0d2640, #0b1620); position: sticky; top:0; z-index:10; border-bottom: 1px solid #123; }
    h1 { margin: 0; font-size: 18px; letter-spacing: .4px; }
    .controls { display:flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    button, select, input { background: var(--panel); color: var(--text); border: 1px solid #234; padding: 8px 10px; border-radius: 8px; }
    button:hover { filter: brightness(1.1); }
    .btn-warn { background: #4a3b10; border-color: #6b520f; }
    .btn-danger { background: #5c1d1d; border-color: #7a2a2a; }
    .btn-ok { background: #0f3a2a; border-color: #17563e; }
    .page { padding: 16px 20px; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 10px; }
    .card { position: relative; background: var(--panel2); border: 1px solid #123; border-radius: 10px; padding: 12px 40px 12px 12px; display:flex; gap: 12px; align-items:flex-start; }
    .deleted { opacity: .6; border-color: #402; background: #1c0f19; }
    .row-top { display:flex; justify-content:space-between; align-items:center; gap:10px; }
    .left { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
    .right { display:flex; gap: 8px; align-items:center; }
    .meta { font-size: 12px; color: var(--muted); display:flex; gap:6px; flex-wrap:wrap; margin-top: 6px; }
    .pill { display:inline-block; padding: 2px 8px; border-radius: 999px; background: #1b3a57; color: #d6ecff; font-size: 11px; margin-right: 6px; }
    .small { font-size: 12px; }
    .muted { color: var(--muted); }
    /* The "×" delete button */
    .del-x {
      position: absolute;
      top: 6px;
      right: 8px;
      width: 26px; height: 26px;
      border-radius: 6px;
      border: 1px solid #6b2a2a;
      background: #5c1d1d;
      color: #ffdede;
      font-weight: 700;
      line-height: 24px;
      text-align: center;
      cursor: pointer;
      user-select: none;
    }
    .del-x:hover { filter: brightness(1.1); }
    .del-x[title] { }
  </style>
</head>
<body>
  <header>
    <h1>Employee Reports – Admin</h1>
    <div class="controls">
      <button id="refreshBtn">Refresh</button>
      <button id="selectAllBtn">Select all</button>
      <button id="clearSelBtn">Clear</button>
      <label class="small"><input type="checkbox" id="showDeleted"> Show deleted</label>
      <a href="/api/export" target="_blank" style="text-decoration:none"><button>Export JSON</button></a>
    </div>
  </header>

  <div class="page">
    <div class="controls">
      <button id="delSoftBtn" class="btn-warn">Delete selected (soft)</button>
      <button id="delHardBtn" class="btn-danger">Delete selected (hard)</button>
      <button id="undoBtn" class="btn-ok">Undo last soft delete</button>
    </div>

    <div class="controls" style="margin-top:10px">
      <label class="small"><input type="checkbox" id="fUnknown"> Email is "Unknown" / empty</label>
      <select id="fTags" multiple size="5" title="Hold Ctrl/Cmd to select multiple">
        ${["Other","Management","Low Pay","Career Growth","Overtime","Benefits","Safety","Culture","Burnout","No issue selected"].map(t => `<option value="${t}">${t}</option>`).join("")}
      </select>
      <span class="small">From: <input type="datetime-local" id="fAfter"></span>
      <span class="small">To: <input type="datetime-local" id="fBefore"></span>
      <button id="fSoftBtn" class="btn-warn">Delete by filter (soft)</button>
      <button id="fHardBtn" class="btn-danger">Delete by filter (hard)</button>
    </div>

    <div id="list" class="grid"></div>
  </div>

  <script>
    const $ = (q) => document.querySelector(q);
    const $$ = (q) => Array.from(document.querySelectorAll(q));
    const state = { data: [], selected: new Set() };

    const fmtDate = (iso) => iso ? new Date(iso).toLocaleString() : "—";
    const tagsPretty = (tags) => Array.isArray(tags) ? tags.map(t => '<span class="pill">' + t + '</span>').join(" ") : "";

    async function fetchReports() {
      const showDeleted = $("#showDeleted").checked;
      const res = await fetch("/api/reports?includeDeleted=" + showDeleted);
      state.data = await res.json();
      render();
    }

    function render() {
      const list = $("#list");
      list.innerHTML = "";
      state.data.forEach(r => {
        const card = document.createElement("div");
        card.className = "card" + (r.deleted_at ? " deleted" : "");
        card.dataset.id = r.id;

        // Small "×" delete button
        const del = document.createElement("div");
        del.className = "del-x";
        del.textContent = "×";
        del.title = "Delete this report (soft). Hold Shift for hard delete.";
        del.addEventListener("click", (ev) => handleRowDelete(ev, r.id));
        card.appendChild(del);

        // Select checkbox (optional if you still want bulk)
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = state.selected.has(r.id);
        cb.addEventListener("change", () => {
          if (cb.checked) state.selected.add(r.id);
          else state.selected.delete(r.id);
        });

        const content = document.createElement("div");
        content.style.flex = "1";

        const top = document.createElement("div");
        top.className = "row-top";
        const left = document.createElement("div");
        left.className = "left";
        left.innerHTML = \`
          <div><strong>\${r.email || "Unknown"}</strong></div>
          <div class="muted">Issue: \${r.issue || "N/A"}</div>
        \`;
        const right = document.createElement("div");
        right.className = "right small";
        right.innerHTML = \`<span class="muted">\${fmtDate(r.created_at)}</span>\`;

        top.appendChild(left);
        top.appendChild(right);

        const meta = document.createElement("div");
        meta.className = "meta";
        meta.innerHTML = tagsPretty(r.tags);

        content.appendChild(top);
        content.appendChild(meta);

        card.appendChild(cb);
        card.appendChild(content);
        list.appendChild(card);
      });
    }

    async function handleRowDelete(ev, id) {
      const hard = ev.shiftKey; // Shift+Click => hard delete
      if (hard && !confirm("Hard delete this report? This cannot be undone.")) return;
      const url = "/api/reports/" + encodeURIComponent(id) + "?soft=" + (!hard);
      const res = await fetch(url, { method: "DELETE" });
      const data = await res.json().catch(() => ({}));
      if (!res.ok) {
        alert("Delete failed: " + (data.error || res.statusText));
        return;
      }
      if (data.deleted === 0) {
        alert("Nothing deleted (maybe already deleted).");
      }
      fetchReports();
    }

    function getSelectedIds() { return Array.from(state.selected); }

    $("#refreshBtn").addEventListener("click", fetchReports);
    $("#selectAllBtn").addEventListener("click", () => { state.data.forEach(r => state.selected.add(r.id)); render(); });
    $("#clearSelBtn").addEventListener("click", () => { state.selected.clear(); render(); });
    $("#showDeleted").addEventListener("change", fetchReports);

    async function postJSON(url, body) {
      const res = await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body) });
      if (!res.ok) throw new Error((await res.json().catch(()=>({}))).error || (res.status + " " + res.statusText));
      return res.json();
    }

    $("#delSoftBtn").addEventListener("click", async () => {
      const ids = getSelectedIds();
      if (!ids.length) return alert("No rows selected.");
      const { deleted } = await postJSON("/api/reports/bulk-delete", { ids, softDelete: true });
      alert("Soft-deleted " + deleted + " report(s).");
      state.selected.clear();
      fetchReports();
    });

    $("#delHardBtn").addEventListener("click", async () => {
      const ids = getSelectedIds();
      if (!ids.length) return alert("No rows selected.");
      if (!confirm("Hard delete " + ids.length + " report(s)? This cannot be undone.")) return;
      const { deleted } = await postJSON("/api/reports/bulk-delete", { ids, softDelete: false });
      alert("Hard-deleted " + deleted + " report(s).");
      state.selected.clear();
      fetchReports();
    });

    function getFilterPayload() {
      const tagIn = Array.from($("#fTags").options).filter(o => o.selected).map(o => o.value);
      const after = $("#fAfter").value ? new Date($("#fAfter").value).toISOString() : null;
      const before = $("#fBefore").value ? new Date($("#fBefore").value).toISOString() : null;
      return { emailIsUnknown: $("#fUnknown").checked, tagIn, createdAfter: after, createdBefore: before };
    }

    $("#fSoftBtn").addEventListener("click", async () => {
      const res = await postJSON("/api/reports/delete-by-filter", { ...getFilterPayload(), softDelete: true });
      alert(\`Soft-deleted \${res.deleted} (would affect: \${res.wouldAffect})\`);
      fetchReports();
    });

    $("#fHardBtn").addEventListener("click", async () => {
      if (!confirm("Hard delete by filter? This cannot be undone.")) return;
      const res = await postJSON("/api/reports/delete-by-filter", { ...getFilterPayload(), softDelete: false });
      alert(\`Hard-deleted \${res.deleted} (would affect: \${res.wouldAffect})\`);
      fetchReports();
    });

    $("#undoBtn").addEventListener("click", async () => {
      const res = await postJSON("/api/reports/undo", {});
      alert("Restored " + res.restored + " report(s).");
      fetchReports();
    });

    // Initial load
    fetchReports();
  </script>
</body>
</html>
`;
}

// ---------- Start server ----------
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log("Server running at http://localhost:" + PORT));
